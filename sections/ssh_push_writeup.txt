
In a large environment with hundreds of systems, a method to push commands and updates to them needs to be in place. This is a separate process from installing and cloning a lab. For example, all systems in a lab need to be shut down for a planned power outage to the building or some other maintenance. Without a method to remotely shut them down, a team of techs is needed to go to every system and shut them down cleanly. This method quickly becomes impractical in labs with hundreds if not thousands of machines. 

Historically, remote shell (RSH), part of the rlogin tools, has been used for this purpose. RSH uses the TCP port 514 to send remote commands to hosts. It does this with a simple authentication mechanism: the username and the source host sending the commands. So long as this combination is in the authorized hosts (.rhosts), the command will be accepted. This is done without any form of encryption over a TCP connection. In an area where the network is heavily secured, this isn't necessarily a bad idea. However, it is fairly trivial to spoof an RSH command by impersonating a user and host. 

The telnet protocol can also be used for this purpose. This protocol actually requires a user name and password to authenticate. It uses TCP port 23. Like rsh, it is not encrypted. While it would be harder to spoof, it is possible to sniff network traffic and gather the authentication credentials. It's also possible to do a man in the middle attack. This is less of an issue on switched networks then it was on hubs historically, but the threat of this occurring still exists, especially if the credentials used are the same for all machines. In addition, scripting a telnet command can be tricky without using a language that can expect a password prompt and act accordingly.

As of this writing, the most common protocol used is Secure Shell (SSH). SSH functions similarly to telnet as far as functionality goes. However, SSH uses public key exchange to create an encrypted channel. In addition, it uses host key identification to make sure that the host connected to is who it says it is. Thus, unless the user disables strict host key checking (on by default), an ssh session is practically immune to man in the middle attacks.  

An ssh session begins by establishing a connection and then exchanging host keys. SSH authentication usually comes in two ways: username/password or authorized keys. Username/password prompts function the same as telnet and are thus not very useful for pushing out commands to a lab.

For the purposes of pushing out remote commands, authorized keys are used. Keys come in pairs: public keys and private keys. Each user can generate a key pair using the "ssh-keygen command". To authenticate with keys instead of passwords, your generated private key should be kept in a ".ssh/" directory of your user account. Pushed your matching public key out to systems you want to access in the same directory of a user on that machine. For example, if you push your public key out to root's home directory on a system, you will be able to login as root on that system without a password. Furthermore, due to the key length, it is much more difficult to brute force a private key than it is a password, and dictionary attacks are practically worthless in this context. 

Because a password prompt never occurs, ssh can be used to run a command immediately after authentication. With the use of semicolons and other special shell characters, multiple commands can be run. Hypothetically, a command to download a script from a webserver can be followed by the command to run that script. 

Thus, a relatively short script can be written to send commands to all participating servers. 


-loop through systems
-complications with hanging processes

